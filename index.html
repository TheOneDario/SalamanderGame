
Skip to content
Pull requests
Issues
Marketplace
Explore
@RPGkia25
TheOneDario /
SalamanderGame
Public

Code
Issues
Pull requests
Actions
Projects
Wiki
Security

    Insights

SalamanderGame/index.html
Academy of Game Dev Camper Fixed the bugs I created
Latest commit a6a277d 8 minutes ago
History
2 contributors
@TheOneDario
@Cheesuee
393 lines (316 sloc) 10.6 KB
<!DOCTYPE html>

<html>

<head>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>

</head>

<body>

    <script>
    //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
    var config = {
        type: Phaser.AUTO,
        width: 1280,
        height: 700,
        physics: {
            default: 'arcade',
        },

        scene: {
            preload: preload,
            create: create,
            update: update,
        }

    };

    class Player extends Phaser.Physics.Arcade.Sprite
    {
        constructor(scene, x, y)
        {
            super(scene, x, y, 'player');
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setScale(1);
            this.setCollideWorldBounds(true);
            this.setGravityY(3000); //We will set gravity *per object* rather than for the scene!
        }
    }

    class Slug extends Phaser.Physics.Arcade.Sprite
    {
        constructor(scene, x, y)
        {
            super(scene, x, y, 'slug');
            this.hp = 1;
            this.scene.physics.add.overlap(arrows, this, this.takeDamage, null, this); // Make the arrow despawn slugs
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setScale(0.4);
            this.setCollideWorldBounds(true);
            this.setGravityY(3000);
        }

        addTween(scene, xDist, yDist, time)
        {
            scene.tweens.add({ targets: this, x: xDist, y: yDist, duration: time, ease: 'Linear', repeat: -1, yoyo: true });
        }

        takeDamage(myArrow, me)
        {
            reverseDespawn(myArrow, me);
            this.hp--;
            if (this.hp < 0)
            {
                despawn(this, this);
            }
        }

        pathfind()
        {

        }
    }

    class WingSlug extends Slug
    {
          fire(myScene, obj)
          {
              if (obj.active)
              {
                  let myVector = new Phaser.Math.Vector2();
                  myVector.x = player.x - obj.x;
                  myVector.y = player.y - obj.y;
                  myVector.normalize();
                  myVector.x += Phaser.Math.Between(-2, 2) / 10;
                  myVector.y += Phaser.Math.Between(-2, 2) / 10;
                  myVector.normalize();

                  let mySlime = new Slime(myScene, obj.x, obj.y, myVector.x * 300, myVector.y * 300);
                  bullets.push(mySlime);
              }
          }

          constructor(scene, x, y)
          {
             super(scene, x, y, 'wingslug');
             scene.add.existing(this);
             scene.physics.add.existing(this);
             this.setScale(0.25);
             this.setCollideWorldBounds(true);
             this.setGravityY(3000);

             var timer = scene.time.addEvent({
                  delay: 300,
                  callback: this.fire,
                  args: [scene, this],
                  callbackScope: scene,
                  loop: true
              });
          }

          pathfind()
          {
                if (this.x < player.x) // If slug is too far left
                {
                      this.setVelocityX(180); // Move right
                }
                else if (this.x > player.x) // If slug is too far right
                {
                      this.setVelocityX(-180); // Move left
                }

                if ((this.y - player.y) > 4) // If more than 4px below player
                {
                      this.setVelocityY(-250); // Jump
                }
          }
    }

    class Arrow extends Phaser.Physics.Arcade.Sprite
    {
        constructor (scene, x, y)
        {
            super(scene, x, y, 'arrow');
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setScale(1);
            this.setCollideWorldBounds(false);

            if (!facingRight)
            {
                this.setFlip(true, false);
                this.setVelocityX(-800);
            }
            else
            {
                this.setVelocityX(800);
            }
        }
    }

    class Slime extends Phaser.Physics.Arcade.Sprite
    {
        constructor(scene, x, y, xSpeed, ySpeed)
        {
            super(scene, x, y, 'slime');
            scene.add.existing(this);
            scene.physics.add.existing(this);
            this.setScale(0.02);
            this.setCollideWorldBounds(false);
            this.setVelocity(xSpeed, ySpeed);
        }
    }



    var game = new Phaser.Game(config);

    //Game Objects
    var layer;
    var player;
    var map;

    //Keyboard controls
    var cursors;
    var keys;
    var space;

    var hp = 4;

    var cooldown = false;
    var hitCooldown = false;

    var facingRight = true;

    var MAX_JUMP_COUNT = 2;
    var currentJumps = MAX_JUMP_COUNT;

    var slugs = [];
    var arrows = [];
    var bullets = [];
    var wingSlugs = [];

    function preload()
    {
        this.load.image('sky', 'assets/bg.png');
        this.load.image('platform', 'assets/platform.png');
        this.load.image('player', 'assets/wabbit.png');
        this.load.image('slug', 'assets/slug.png');
        this.load.image('wingslug', 'assets/slug.png');
        this.load.image('arrow', 'assets/arrow.png');
        this.load.image('bullet', 'assets/bullet.png');
        this.load.image('slime', 'assets/slime.png');
        this.load.image('tileset', 'assets/jungleTileSet.png');
        this.load.tilemapTiledJSON('tilemap', 'assets/level1v2.json');
    }

    function despawn(despawner, despawnee)
    {
        despawnee.disableBody(true, true); //remove that particuhp--;
    }

    function reverseDespawn(despawnee, despawner)
    {
        despawnee.disableBody(true, true);
    }
    // Music credit: Music by Marllon Silva (xDeviruchi)

    /**
    TODO: Add bullets that can hit slugs
    TODO: Make camera follow player around the level
    TODO: Import tileset and level
    TODO: Win condition
    TODO: Maybe NPCs
    **/

    function CollisionDamage(myPlayer, myEnemy)
    {
        if (!hitCooldown)
        {
            hitCooldown = true;
            this.time.delayedCall(500, resetHitCooldown, [], this); // Make cooldown stop in 1 second
            TakeDamage(1);
        }
    }

    function CollisionDeleter(myPlayer, myEnemy)
    {
        if (!hitCooldown)
        {
            despawn(this, myEnemy);
            hitCooldown = true;
            this.time.delayedCall(500, resetHitCooldown, [], this); // Make cooldown stop in 1 second
            TakeDamage(1);
        }
    }

    function  TakeDamage(amount)
    {
        hp -= amount;
        info.setText(hp);
        console.log(hp);
    }







    function create()
    {
        //Set the background origin to be at (0, 0) or top left corner of the image rather than the center of the image asset
       let background = this.add.tileSprite(0, 0, game.scale.width, game.scale.height, 'sky').setOrigin(0, 0);

       //Create the layer and the player character set to collide with the layer
       player = new Player(this, 100, 50);
       this.physics.add.collider(player, layer);
       this.physics.add.overlap(player, slugs, CollisionDamage, null, this);
       this.physics.add.overlap(player, bullets, CollisionDeleter, null, this);

       info = this.add.text(player.x - 200, player.y + 200, '4', { font: '48px Arial', fill: '#000000' });

       slug = new Slug(this, 600, 605.6);
       this.physics.add.collider(slug, layer);
       slug.addTween(this, slug.x + 200, slug.y, 2000);
       slugs.push(slug); // add to list of slugs

       wingSlug = new WingSlug(this, 200, 605.6);
       this.physics.add.overlap(wingSlug, player);
       this.physics.add.collider(wingSlug, layer);
       slugs.push(wingSlug); // add to list of winged slugs

       //Set up user input
       cursors = this.input.keyboard.createCursorKeys();
       keys = this.input.keyboard.addKeys('A, D');
       space = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
       space.on('down', jump); //calls jump function when space is pressed



       this.physics.add.overlap(bullets, layer, reverseDespawn, null, this);

       this.cameras.main.setBounds(0, 0, 10000, 10000);
       this.cameras.main.startFollow(player, true, 0.08, 0.04);
       this.cameras.main.setZoom(2);

       //adds tileset map
       map = this.make.tilemap({ key: 'tilemap'});
       var tileset = map.addTilesetImage('jungleTileSet', 'tileset');
       var layer = map.createLayer(0, tileset, 0, 0);
       layer.setCollisionByExclusion([-1]);
       this.physics.add.collider(player, layer);
       layer.setScale(1.37);
    }



    function update(time, delta)
    {
        //Player will not move in the x-axis unless a movement key is being pressed
        player.setVelocityX(0);

        //Player has "drag" on the x-axis meaning they slide a bit after an input
        player.setDragX(1000);

        //Handle player movements
        if (cursors.left.isDown || keys.A.isDown)
        {
            facingRight = false;
            player.setVelocityX(-400);
        }

        if (cursors.right.isDown || keys.D.isDown)
        {
            facingRight = true;
            player.setVelocityX(400);
        }

        for (let i = 0; i < slugs.length; i++) // For each winged slug
        {
              slugs[i].pathfind(); // Make each wing slug move towards player
        }

        if (cursors.up.isDown && !cooldown)
        {
            cooldown = true; // Turn on arrow cooldown
            this.time.delayedCall(1000, resetCooldown, [], this); // Make cooldown stop in 1 second

            let offset = 50;
            if (facingRight)
            {
                offset = 50;
            }
            else {
                offset = -50;
            }

            myArrow = new Arrow(this, player.x + offset, player.y); // Spawn arrow



            this.physics.add.overlap(myArrow, slugs, despawn, null, this); // Make the arrow despawn slugs
            this.physics.add.overlap(myArrow, layer, reverseDespawn, null, this); // Make layer despawn the arrow
        }

        info.x = this.cameras.main.worldView.x + 25;
        info.y = this.cameras.main.worldView.y + 20;
    }

    function resetCooldown()
    {
        cooldown = false;
    }

    function resetHitCooldown()
    {
        hitCooldown = false;
    }

    function jump(event)
    {
        if (player.body.onFloor())
        {
             currentJumps = MAX_JUMP_COUNT - 1;
            player.setVelocityY(-900); // previously was 1100
        }
        else if (currentJumps > 0)
        {
            currentJumps--;
            player.setVelocityY(-700);
       }
    }

    </script>

</body>

</html>
Footer
Â© 2022 GitHub, Inc.
Footer navigation

    Terms
    Privacy
    Security
    Status
    Docs
    Contact GitHub
    Pricing
    API
    Training
    Blog
    About

You have no unread notifications
